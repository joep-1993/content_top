#!/usr/bin/env python3
"""
Extract and explain popularity metrics for top 100 products.
"""

import requests
import json
import csv
from typing import List, Dict, Any

# Configuration
ES_BASE_URL = "https://elasticsearch-job-cluster-eck.beslist.nl"
SNEAKER_CATEGORY_INDEX = "product_search_v5_32000"


def fetch_top_products_with_metrics(limit: int = 100) -> List[Dict[str, Any]]:
    """
    Fetch top products with all popularity-related metrics.
    
    Args:
        limit: Number of products to fetch
    
    Returns:
        List of product dictionaries with full metrics
    """
    
    query = {
        "size": limit,
        "query": {
            "bool": {
                "must": [
                    {
                        "match": {
                            "indexedCategoryField": "sneakers"
                        }
                    }
                ],
                "filter": [
                    {
                        "term": {
                            "valid": True
                        }
                    },
                    {
                        "range": {
                            "shopCountNl": {
                                "gt": 0
                            }
                        }
                    }
                ]
            }
        },
        "sort": [
            {
                "popularity": {
                    "order": "desc"
                }
            }
        ],
        "_source": [
            "id",
            "title",
            "brandName",
            "minPrice",
            
            # Main popularity metrics
            "popularity",
            "popularityBe",
            "alternativePopularity",
            "alternativePopularityBe",
            
            # Detailed popularity data
            "popularityData.clickFactor",
            "popularityData.costPerPopUpClick",
            "popularityData.roasPercentage",
            "popularityData.webshopsRevenuePerClick",
            
            # Belgian popularity data
            "popularityBeData.clickFactor",
            "popularityBeData.costPerPopUpClick",
            "popularityBeData.roasPercentage",
            "popularityBeData.webshopsRevenuePerClick",
            
            # Additional metrics
            "predictedRevenuePerClick",
            "brandRank",
            "brandRankBe",
            "brandRelativeDemandLabel",
            "brandRelativeDemandLabelBe",
            "productScoreLabel",
            "eanScoreLabel",
            
            # Shop and sales data
            "shopCountNl",
            "shopCountBe",
            "bestseller.google",
            "bestseller.googleTop100",
            "bestsellerBe.google",
            "bestsellerBe.googleTop100"
        ]
    }
    
    url = f"{ES_BASE_URL}/{SNEAKER_CATEGORY_INDEX}/_search"
    headers = {"Content-Type": "application/json"}
    
    print(f"Fetching top {limit} products with popularity metrics...")
    response = requests.post(url, json=query, headers=headers)
    response.raise_for_status()
    
    result = response.json()
    print(f"Successfully fetched {len(result['hits']['hits'])} products")
    
    return result['hits']['hits']


def extract_metrics(hit: Dict[str, Any]) -> Dict[str, Any]:
    """
    Extract all popularity metrics from Elasticsearch hit.
    
    Args:
        hit: Elasticsearch hit document
    
    Returns:
        Flat dictionary with all metrics
    """
    source = hit.get('_source', {})
    
    # Extract nested popularity data
    pop_data = source.get('popularityData', {})
    pop_data_be = source.get('popularityBeData', {})
    bestseller = source.get('bestseller', {})
    bestseller_be = source.get('bestsellerBe', {})
    
    return {
        'rank': None,  # Will be set later
        'product_id': source.get('id', ''),
        'title': source.get('title', ''),
        'brand': source.get('brandName', ''),
        'price_eur': source.get('minPrice', 0),
        
        # Main popularity scores
        'popularity_score': source.get('popularity', 0),
        'popularity_score_be': source.get('popularityBe', 0),
        'alternative_popularity': source.get('alternativePopularity', 0),
        'alternative_popularity_be': source.get('alternativePopularityBe', 0),
        
        # Popularity components (NL)
        'click_factor': pop_data.get('clickFactor', 0),
        'cost_per_popup_click': pop_data.get('costPerPopUpClick', 0),
        'roas_percentage': pop_data.get('roasPercentage', 0),
        'webshops_revenue_per_click': pop_data.get('webshopsRevenuePerClick', 0),
        
        # Popularity components (BE)
        'click_factor_be': pop_data_be.get('clickFactor', 0),
        'cost_per_popup_click_be': pop_data_be.get('costPerPopUpClick', 0),
        'roas_percentage_be': pop_data_be.get('roasPercentage', 0),
        'webshops_revenue_per_click_be': pop_data_be.get('webshopsRevenuePerClick', 0),
        
        # Additional metrics
        'predicted_revenue_per_click': source.get('predictedRevenuePerClick', 0),
        'brand_rank': source.get('brandRank', 0),
        'brand_rank_be': source.get('brandRankBe', 0),
        'brand_demand_label': source.get('brandRelativeDemandLabel', ''),
        'brand_demand_label_be': source.get('brandRelativeDemandLabelBe', ''),
        
        # Quality scores
        'product_score': source.get('productScoreLabel', ''),
        'ean_score': source.get('eanScoreLabel', ''),
        
        # Shop counts
        'shops_nl': source.get('shopCountNl', 0),
        'shops_be': source.get('shopCountBe', 0),
        
        # Bestseller flags
        'google_bestseller': bestseller.get('google', False),
        'google_top100': bestseller.get('googleTop100', False),
        'google_bestseller_be': bestseller_be.get('google', False),
        'google_top100_be': bestseller_be.get('googleTop100', False)
    }


def calculate_derived_metrics(products: List[Dict[str, Any]]) -> None:
    """
    Calculate derived metrics to understand popularity formula.
    
    Args:
        products: List of product dictionaries
    """
    
    for product in products:
        # Try to understand the formula
        # Hypothesis: popularity = click_factor * some_weight
        if product['click_factor'] > 0:
            product['popularity_per_click'] = product['popularity_score'] / product['click_factor']
        else:
            product['popularity_per_click'] = 0
        
        # Calculate potential revenue impact
        if product['webshops_revenue_per_click'] > 0 and product['cost_per_popup_click'] > 0:
            product['revenue_efficiency'] = product['webshops_revenue_per_click'] / product['cost_per_popup_click']
        else:
            product['revenue_efficiency'] = 0


def save_to_csv(products: List[Dict[str, Any]], filename: str = 'popularity_explained_top100.csv'):
    """
    Save products with all metrics to CSV file.
    
    Args:
        products: List of product dictionaries
        filename: Output CSV filename
    """
    
    if not products:
        print("No products to save")
        return
    
    # Define CSV columns
    fieldnames = [
        'rank', 'product_id', 'title', 'brand', 'price_eur',
        
        # Main popularity
        'popularity_score', 'popularity_score_be',
        'alternative_popularity', 'alternative_popularity_be',
        
        # Components
        'click_factor', 'cost_per_popup_click', 
        'roas_percentage', 'webshops_revenue_per_click',
        
        # Belgian components
        'click_factor_be', 'cost_per_popup_click_be',
        'roas_percentage_be', 'webshops_revenue_per_click_be',
        
        # Derived metrics
        'popularity_per_click', 'revenue_efficiency',
        
        # Additional metrics
        'predicted_revenue_per_click',
        'brand_rank', 'brand_demand_label',
        'product_score', 'ean_score',
        'shops_nl', 'shops_be',
        'google_bestseller', 'google_top100'
    ]
    
    print(f"Saving {len(products)} products to {filename}...")
    
    with open(filename, 'w', newline='', encoding='utf-8') as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames, extrasaction='ignore')
        writer.writeheader()
        
        for rank, product in enumerate(products, 1):
            product['rank'] = rank
            writer.writerow(product)
    
    print(f"Successfully saved to {filename}")


def analyze_popularity_formula(products: List[Dict[str, Any]]) -> None:
    """
    Analyze the relationship between popularity components.
    
    Args:
        products: List of product dictionaries
    """
    
    print("\n" + "=" * 60)
    print("POPULARITY FORMULA ANALYSIS")
    print("=" * 60)
    
    # Find products with complete data
    complete_products = [p for p in products if p['click_factor'] > 0]
    
    if complete_products:
        # Analyze the relationship
        print(f"\nAnalyzing {len(complete_products)} products with complete data:")
        
        # Check if popularity = click_factor * constant
        ratios = [p['popularity_per_click'] for p in complete_products[:10]]
        
        print("\nTop 10 products - Popularity divided by Click Factor:")
        for i, p in enumerate(complete_products[:10], 1):
            print(f"  {i}. {p['brand'][:20]:20} | Popularity: {p['popularity_score']:6.0f} | "
                  f"Clicks: {p['click_factor']:4} | Ratio: {p['popularity_per_click']:.2f}")
        
        # Check correlation with revenue metrics
        print("\nRevenue Metrics for Top 10:")
        for i, p in enumerate(complete_products[:10], 1):
            print(f"  {i}. Revenue/Click: €{p['webshops_revenue_per_click']:.2f} | "
                  f"Cost/Click: €{p['cost_per_popup_click']:.2f} | "
                  f"ROAS: {p['roas_percentage']}%")
        
        # Summary statistics
        print("\nKey Insights:")
        print(f"  - Popularity scores range: {min(p['popularity_score'] for p in products)} - "
              f"{max(p['popularity_score'] for p in products)}")
        print(f"  - Click factors range: {min(p['click_factor'] for p in complete_products)} - "
              f"{max(p['click_factor'] for p in complete_products)}")
        print(f"  - Average ROAS: {sum(p['roas_percentage'] for p in complete_products) / len(complete_products):.0f}%")
        
        # Check if there's a simple formula
        if len(set(ratios[:5])) == 1:
            print(f"\n✓ FORMULA FOUND: Popularity = Click Factor × {ratios[0]:.2f}")
        else:
            print(f"\n✗ The formula is more complex than a simple multiplication")
            print(f"  The ratio varies between products, suggesting additional factors")


def main():
    """Main function to analyze popularity metrics."""
    
    print("=" * 60)
    print("EXTRACTING POPULARITY METRICS FOR TOP 100 PRODUCTS")
    print("=" * 60)
    
    try:
        # Fetch products with full metrics
        hits = fetch_top_products_with_metrics(limit=100)
        
        # Extract and transform data
        products = [extract_metrics(hit) for hit in hits]
        
        # Calculate derived metrics
        calculate_derived_metrics(products)
        
        # Analyze the formula
        analyze_popularity_formula(products)
        
        # Save to CSV
        save_to_csv(products)
        
        print("\n" + "=" * 60)
        print("EXPLANATION OF METRICS")
        print("=" * 60)
        print("""
The popularity score appears to be based on:

1. **Click Factor**: Number of clicks or interactions
2. **Cost Per Popup Click**: What it costs per click (€)
3. **ROAS Percentage**: Return on Ad Spend (higher is better)
4. **Webshops Revenue Per Click**: How much revenue each click generates (€)

The formula seems to weight these factors to create the final popularity score.
Products with higher click rates and better revenue efficiency rank higher.
        """)
    
    except requests.exceptions.RequestException as e:
        print(f"Error fetching data: {e}")
    except Exception as e:
        print(f"Error: {e}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    main()